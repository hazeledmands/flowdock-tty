(function() {
  var Session, Stream, baseURL, events, request, url,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  url = require('url');

  events = require('events');

  request = require('request');

  Stream = require('./stream');

  baseURL = function() {
    return url.parse(process.env.FLOWDOCK_API_URL || 'https://api.flowdock.com');
  };

  Session = (function(_super) {

    __extends(Session, _super);

    function Session(email, password) {
      this.email = email;
      this.password = password;
      this.auth = 'Basic ' + new Buffer(this.email + ':' + this.password).toString('base64');
    }

    Session.prototype.flows = function(callback) {
      var options, uri,
        _this = this;
      uri = baseURL();
      uri.path = '/flows?users=1';
      options = {
        uri: uri,
        method: 'GET',
        headers: {
          'Authorization': this.auth,
          'Accept': 'application/json'
        }
      };
      return request(options, function(error, res, body) {
        var flows;
        if (error) {
          _this.emit('error', 'Couldn\'t connect to Flowdock');
          return;
        }
        if (res.statusCode > 300) {
          _this.emit('error', res.statusCode);
          return;
        }
        flows = JSON.parse(body.toString("utf8"));
        return callback(flows);
      });
    };

    Session.prototype.stream = function(flows, options) {
      if (options == null) options = {};
      if (!Array.isArray(flows)) flows = [flows];
      return Stream.connect(this.auth, flows, options);
    };

    Session.prototype.send = function(flow, message, callback) {
      var options, uri,
        _this = this;
      uri = baseURL();
      uri.path = "/flows/" + (flow.replace(':', '/')) + "/messages";
      options = {
        uri: uri,
        method: 'POST',
        json: message,
        headers: {
          'Authorization': this.auth,
          'Accept': 'application/json'
        }
      };
      return request(options, function(error, res, body) {
        if (error) {
          _this.emit('error', 'Couldn\'t connect to Flowdock');
          return;
        } else if (res.statusCode >= 300) {
          _this.emit('error', res.statusCode);
          return;
        }
        if (callback) return callback(res);
      });
    };

    Session.prototype.message = function(flow, message, tags) {
      var data;
      data = {
        event: 'message',
        content: message,
        tags: tags || []
      };
      return this.send(flow, data);
    };

    Session.prototype.status = function(flow, status) {
      var data;
      data = {
        event: 'status',
        content: status
      };
      return this.send(flow, data);
    };

    return Session;

  })(process.EventEmitter);

  exports.Session = Session;

}).call(this);
