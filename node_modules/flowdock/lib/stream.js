(function() {
  var JSONStream, Stream, backoff, baseURL, request, url,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  url = require('url');

  request = require('request');

  JSONStream = require('./json_stream');

  baseURL = function() {
    return url.parse(process.env.FLOWDOCK_STREAM_URL || 'https://stream.flowdock.com/flows');
  };

  backoff = function(backoff, errors, operator) {
    if (operator == null) operator = '*';
    return Math.min(backoff.max, (operator === '+' ? errors : Math.pow(2, errors - 1)) * backoff.delay);
  };

  Stream = (function(_super) {

    __extends(Stream, _super);

    function Stream(auth, flows, params) {
      var _this = this;
      this.auth = auth;
      this.flows = flows;
      this.params = params != null ? params : {};
      this.networkErrors = 0;
      this.responseErrors = 0;
      this.on('reconnecting', function(timeout) {
        return setTimeout(function() {
          return _this.connect();
        }, timeout);
      });
    }

    Stream.prototype.connect = function() {
      var errorHandler,
        _this = this;
      if (this.disconnecting) return;
      errorHandler = function(error) {
        _this.networkErrors += 1;
        _this.emit('clientError', 0, 'Network error');
        return _this.emit('reconnecting', backoff(Stream.backoff.network, _this.networkErrors, '+'));
      };
      this.request = request(this.options()).on('response', function(response) {
        var parser;
        _this.request.removeListener('error', errorHandler);
        _this.networkErrors = 0;
        if (response.statusCode >= 400) {
          _this.responseErrors += 1;
          _this.emit('clientError', response.statusCode);
          return _this.emit('reconnecting', backoff(Stream.backoff.error, _this.responseErrors, '*'));
        } else {
          _this.responseErrors = 0;
          parser = new JSONStream();
          parser.on('data', function(message) {
            return _this.emit('message', message);
          });
          _this.request.on('abort', function() {
            parser.removeAllListeners();
            _this.emit('disconnected');
            return _this.emit('end');
          });
          parser.on('end', function() {
            parser.removeAllListeners();
            _this.emit('disconnected');
            _this.emit('clientError', 0, 'Disconnected');
            return _this.emit('reconnecting', 0);
          });
          _this.request.pipe(parser);
          return _this.emit('connected');
        }
      });
      this.request.once('error', errorHandler);
      return this.request;
    };

    Stream.prototype.options = function() {
      var key, options, value, _ref;
      options = {
        uri: baseURL(),
        qs: {
          filter: this.flows.join(',')
        },
        method: 'GET',
        headers: {
          'Authorization': this.auth,
          'Accept': 'application/json'
        }
      };
      _ref = this.params;
      for (key in _ref) {
        value = _ref[key];
        options.qs[key] = value;
      }
      return options;
    };

    Stream.prototype.end = function() {
      this.disconnecting = true;
      if (this.request) {
        this.request.abort();
        this.request.removeAllListeners();
        return this.request = void 0;
      }
    };

    Stream.prototype.close = function() {
      console.warn('DEPRECATED, use Stream#end() instead');
      return this.end();
    };

    return Stream;

  })(process.EventEmitter);

  Stream.connect = function(auth, flows, params) {
    var stream;
    stream = new Stream(auth, flows, params);
    stream.connect();
    return stream;
  };

  Stream.backoff = {
    network: {
      delay: 200,
      max: 10000
    },
    error: {
      delay: 2000,
      max: 120000
    }
  };

  module.exports = Stream;

}).call(this);
